# sync

## sync.Mutex和sync.RWMutex

### 竞态条件、临界区和同步工具

Go语言宣扬“**用通信的方式共享数据**”，但是，**通过共享数据的方式来传递信息和协调线程运行**的做法其实更加主流，大部分现代编程语言都使用后一种方式作为并发编程的解决方案。

> 一旦数据被多个线程共享，很可能会产生争用和冲突的情况，这种情况称为**竞态条件（race condition）**，这往往会破坏共享数据的一致性。

**共享数据的一致性代表着：多个线程对共享数据的操作总是可以达到它们各自预期的效果**。

同步的用途有两个：

1. 避免多个线程，在同一时刻操作同一个**数据块**
2. 协调多个线程，避免它们在同一时刻执行同一个**代码块**

这些数据块和代码块的背后都隐含着一种或多种资源（如存储资源，计算资源、I/O资源、网络资源等），把它们看成是共享资源，**同步其实就是在控制多个线程对共享资源的访问**。

如果某个共享资源的访问，在同一时刻只能有一个线程进行，那么多个并发线程对该共享资源的访问是完全串行的。只要一个代码块需要实现对共享资源的串行化访问，就可以被视为一个临界区（critical section），由于要访问到资源而必须进入的那个区域。

> 如果针对同一个共享资源，这样的代码块有多个，那么它们成为相关临界区。
>
> 1. 它们可以是一个内含了共享数据的结构体及其方法，
> 2. 也可以是操作同一块共享数据的多个函数。

临界区总是需要收到保护，否则就会产生竞态条件，施加保护的重要手段之一，就是**使用实现了某种同步机制的工具**，称为同步工具。

![image](/images/sync.png)

在Go语言中，可供选择的同步工具不少，最重要最常用的同步工具是**互斥量（mutual exclusion，简称mutex）**。sync包中的Mutex就是与其对应的类型，该类型的值可以被称为互斥量或者互斥锁。

> 一个互斥锁可以被用来包含一个临界区或者一组相关临界区，通过它来保证在同一时刻只有一个goroutine处于该临界区内。每当有goroutine想进入临界区时，都需要先对它进行锁定，离开时要及时进行解锁。

- 锁定操作可以通过调用互斥锁的Lock方法实现
- 解锁操作可以通过调用互斥锁的Unlock方法实现

```go
mu.Lock()
_, err := writer.Write([]byte(data))
if err != nil {
    log.Printf("error:%s[%d]",err,id)
}
mu.UnLock()
```

### 使用互斥锁注意事项

1. 不要重复锁定互斥锁：
   > 对于一个已经锁定的互斥锁进行锁定，会立即阻塞当前的goroutine，这个goroutine执行的流程会一直停滞在调用该互斥锁的Lock方法的那行代码上。直到互斥锁的Unlock方法被调用，并且这里的锁定操作成功之后，临界区的代码才会执行。
2. 不要忘记解锁互斥锁，必要时使用defer语句
    > 可以避免出现重复锁定。因为忘记接收会使得其他goroutine无法进入到互斥锁保护的临界区中，轻则功能失效，重则死锁崩溃。

    > 程序的流程可以分叉也可以被中断，所以一个流程在锁定某个互斥锁之后，紧跟着defer语句进行接收是比较稳妥的。
3. 不要对尚未锁定或者已解锁的互斥锁解锁
    > 解锁未锁定的互斥锁会立即引起panic。与死锁的panic一样，无法被恢复。**因此对于每一个锁定操作有且只有一个对应的解锁操作**。
4. 不要在多个函数之间直接传递互斥锁

> 死锁，当前程序中的主goroutine，以及启用的那些goroutine都已经被阻塞，这些goroutine可以被统称为用户级的goroutine，这就相当于整个程序都已经停滞不前了。

Go语言运行时系统不允许这种情况出现，当发现所以用户级goroutine都处于等待会抛出如下panic：

```go
fatal error: all goroutines are asleep - deadlock!
```

**Go语言运行时系统自行抛出的panic都属于致命错误，无法被恢复，调用recover函数对它们起不到任何作用，程序死锁，必然崩溃**。

当每个互斥锁都只保护一个临界区或者一组相关临界区可以有效避免死锁。

### 传递互斥锁

Go语言中的互斥锁是开箱即用的，声明一个sync.Mutex类型（该类型是一个**结构体**类型，属于**值类型**）的变量就可以直接使用了。

对于值类型的操作，把它传给一个函数，将它从函数中返回，把它赋给其他变量，让它进入某个通道都会导致它的副本的产生。**原值与副本、副本与副本之间都是完全独立的，它们都是不同的互斥锁**。

> 如果把一个互斥锁作为参数产给了一个函数，那么在这个函数中对传入的锁的所有操作，都不会对存在于该函数之外的那个原锁产生任何的影响。

### 读写锁与互斥锁的区别

读写锁是读/写互斥锁的简称，在Go语言中，读写锁由`sync.RWMutex`类型的值代表，也是开箱即用。

读写锁把读操作和写操作区别对待，可以对这两种操作施加不同的保护。相比于互斥锁，读写锁实现更加细粒度的访问控制。一个读写锁中包含两个锁：

1. 写锁：`sync.RWMutex`类型中的Lock方法和Unlock方法分别用于对写锁进行锁定和解锁
2. 读锁：`sync.RWMutex`类型中的RLock方法和RUnlock方法分别用于对于读锁进行锁定和解锁

对于同一个读写锁来说，有如下规则：

1. 在**写锁**已被锁定的情况下，再试图锁定**写锁**，会阻塞当前goroutine
2. 在**写锁**已被锁定的情况下，再试图锁定**读锁**，会阻塞当前goroutine
3. 在**读锁**已被锁定的情况下，再试图锁定**写锁**，会阻塞当前的goroutine
4. 在**读锁**已被锁定的情况下，再试图锁定**读锁**，不会阻塞当前goroutine

也就是说，对于某个收到读写锁包含的共享资源：

1. 多个写操作不能同时进行
2. 读操作和写操作不能同时进行
3. 多个读操作可以同时进行

**通常不能同时进行的操作称为互斥操作**。

- 对于**写锁**进行解锁操作，会唤醒**所有因试图锁定读锁而被阻塞的goroutine**，通常会使它们都成功完成对读锁的锁定。
- 对于**读锁**进行解锁操作，只会在没有其他**读锁**锁定的前提下，唤醒**因试图锁定写锁而被阻塞的goroutine**，并且最终只会有一个被唤醒的goroutine（等待时间最长的那个）成功完成对**写锁**的锁定，其他goroutine继续等待。

**读写锁中对写操作之间的互斥是通过内涵的一个互斥锁实现的**，在Go语言中，读写锁是互斥锁的一种扩展。

### 总结

互斥锁常常被用来保证多个goroutine并发访问同一个共享资源时的完全串行。

1. 不要忘记锁定或忘记解锁，这会导致goroutine的阻塞甚至死锁
2. 不要传递互斥锁，这会产生它的副本，从而产生奇异或者导致互斥失效
3. 让每一个互斥锁都只包含一个临界区，或一组相关临界区
4. 不要解锁未锁定的锁，会引发不可恢复的panic

## sync.Cond

### 条件变量与互斥锁

条件变量是另一个同步工具，它是基于互斥锁的，它不是用来包含临界区和共享资源 的，而是用于**协调想要访问共享资源的那些线程**。当共享资源的状态发生变化时，它可以被用来通知互斥锁阻塞的线程。

**条件变量的初始化离不开互斥锁，并且它的方法有的也是基于互斥锁的**。

条件变量有三个方法：

1. 等待通知（Wait）：在互斥锁保护下进行
2. 单发通知（signal）：在互斥锁解锁后进行
3. 广播通知（broadcast）：在互斥锁解锁后进行

```go
var mailbox uint8
var lock sync.RWMutex   // 读写锁
sendCond := sync.NewCond(&lock)     // 条件变量
recvCond := sync.NewCond(lock.RLocker())        // 条件变量

// func NewCond(l Locker) *Cond  返回带有锁的条件变量的指针值

// goroutine 1
lock.Lock() // 锁定写锁
for mailbox == 1 {  // 如果有情报就等待
 sendCond.Wait()    // 解锁写锁，加入通知队列，阻塞当前代码行
}
mailbox = 1     // 如果没有情报就放入情报。1表示放入情报
lock.Unlock()   // 解锁写锁
recvCond.Signal()   // 发起通知情报已经放好

// goroutine 2
lock.RLock()    // 锁定读锁
for mailbox == 0 {  // 如果没有情报就等待
 recvCond.Wait()    // 解锁读锁，加入通知队列，阻塞当前代码行
}
mailbox = 0     // 如果有情报就取出情报。0表示取出情报
lock.RUnlock()  // 解锁读锁
sendCond.Signal()   // 发起通知情报已经取走

```

只要条件不满足，就会调用wait方法，需要发起通知就调用signal方法。使用条件变量实现单向通知，双向通知需要两个条件变量，这是条件变量的基本使用规则。

### Wait方法

条件变量的Wait方法主要做了四件事情：

1. 把调用它的goroutine（即当前goroutine）加入到当前条件变量的通知队列中
2. 解锁当前的条件变量基于的那个互斥锁（**条件变量的Wait方法在阻塞当前goroutine前，会解锁它基于的互斥锁，所以在调用Wait之前，必须先锁定互斥锁，否则调用Wait方法会引发不可恢复的painc**。）
    > 如果Wait方法不先解锁互斥锁，那么只会有两种后果，不是当前程序因panic而崩溃，就是相关的goroutine全面阻塞。
3. 让当前的goroutine处于等待状态，等到通知到来时再决定是否唤醒它，此时，这个goroutine就会阻塞在调用这个Wait方法的那行代码上
4. 如果通知到来并且决定唤醒这个goroutine，那么就在唤醒它之后重新锁定当前条件变量基于的互斥锁，自此之后，当前的goroutine就会继续执行后面的代码了

需要使用for循环包裹Wait方法来多次检查共享资源的状态，因为当一个goroutine收到通知被唤醒，但却发现共享组员的状态依然不符合要求，那么应该再次调用条件变量Wait方法，并继续等待下一次通知的到来。例如下面的情况：

1. 多个goroutine等待共享资源的同一种状态。
2. 共享资源有多种状态，单一的结果不可能满足所以goroutine的条件。
3. 某些多CPU核心的计算机系统中洪，没有收到条件变量的通知，调用其Wair方法的goroutine也可能会被唤醒，这是计算机硬件层面决定的，即使是操作系统本身提供的条件变量也会如此。

**综上，在包裹条件变量的Wait方法时，总是应该使用for语句**，因为等待通知而被阻塞的goroutine可能会在共享资源的状态不满足其要求的情况下被唤醒。

### Signal方法与Broadcast方法的区别

- 共同点：都是被用来发送通知的
- 不同点：
  - 前者的通知只会唤醒一个因此而等待的goroutine
    > 条件变量的Wait方法总是会把当前goroutine添加到通知队列的队尾，而signal方法总会从通知队列的队首开始，查找可被唤醒的goroutine。因此会唤醒最早等待的那一个。
  - 后者的通知会唤醒所有为此等待的goroutine

这两个方法的行为决定了它们的使用场景。

- 如果确定只有一个goroutine在等待，或者只许唤醒任意一个goroutine就可以满足要求，那么使用Signal方法。
- 否则，使用Broadcast方法总每次，只要设置好各个goroutine所期望的共享资源状态即可。

**与Wait方法不同，Signal方法和Broadcast方法并不需要在互斥锁的保护下进行**。最好在解锁条件变量基于的互斥锁之后在调用它们。**这更有利于程序的运行效率**。

条件变量的通知具有即时性，即在发送通知的时候没有goroutine为此等待，那么该通知就会被直接丢弃。在这之后才开始等待的goroutine只可能被后面的通知唤醒。

**通过对互斥锁的合理使用，可以是一个goroutine在执行临界区中的代码时，不被其他的goroutine打扰。不过，虽然不会被打扰，但是它仍然可能会被终端（interruption）**。

## sync.WaitGroup 和 sync.Once

使用通道进行多goroutine协作：声明一个通道，使它的容量与手动启动的goroutine的数量相同，之后再利用这个通道，让主goroutine等待其他goroutine的运行结束。

```go
func coordinateWithChan() {
 sign := make(chan struct{}, 2)
 num := int32(0)
 fmt.Printf("The number: %d [with chan struct{}]\n", num)
 max := int32(10)
 go addNum(&num, 1, max, func() {
  sign <- struct{}{}
 })
 go addNum(&num, 2, max, func() {
  sign <- struct{}{}
 })
 <-sign
 <-sign
}
```

以上操作，略显丑陋。

使用`sync`包的`WaitGroup`类型，它比通道更加适合这种一对多的goroutine协作流程。

`sync.WaitGroup`开箱即用，并发安全，同样的它一旦真正被使用，就不能再被复制。

WaitGroup有三个指针方法：

- Add：可以想象在该类型中有一个计数器，默认值为0，可以调用该值类型的Add方法来增加或者减少这个计数器的值。一般用来记录等待的goroutine的数量。
- Done：对计数器中的值进行减操作，可以在需要等待的goroutine中，通过defer语句调用它。
- Wait：阻塞当前的goroutine，直到其所属值中的计数器归零。如果在该方法调用的时候，计数器的值已经是0，那么就不做任何事情。

将上面代码修改为WaitGroup版本：

```go
func coordinateWithWaitGroup() {
 var wg sync.WaitGroup
 wg.Add(2)
 num := int32(0)
 fmt.Printf("The number: %d [with sync.WaitGroup]\n", num)
 max := int32(10)
 go addNum(&num, 3, max, wg.Done)
 go addNum(&num, 4, max, wg.Done)
 wg.Wait()
}
```

### 注意点

`sync.WaitGroup`类型值中计数器的值**不能小于**0。如果小于0，会引发一个panic。不适当的调用Done方法和Add方法都会引起这个问题，因为在Add方法中可以传入一个负数。

> 如果同时调用Add方法和Wait方法，假设在两个goroutine中，分别调用这两个方法，**那么就可能会让这个Add方法抛出panic**。这种情况不容易复现，虽然WaitGroup值本身并不需要初始化，但是尽早增加其计数器的值，是非常有必要的。

WaitGroup值是可以被复用的，但是需要保证其计数周期的完整性。在WaitGroup值的生命周期中，它可以经历任意多个计数周期。**但是只有在它走完当前的计数周期之后，才能够开始下一个计数周期**。

> 计数周期：WaitGroup值中的计数器值有0变为某个正整数，然后经过一系列的变化，最终由某个正整数又变回0。

![images](/images/WaitGroup.png)

**因此，如果某个WaitGroup值的Wait方法在某个计数周期中被调用，会立即阻塞当前的goroutine，直到这个计数周期完成，在这种情况下，该值的下一个计数周期必须等到Wait方法执行结束之后，才能够开始**。

如果在一个此类值的Wait方法被执行期间，跨越了两个计数周期，**会引发一个panic**。举个例子：

1. 在当前goroutine因调用WaitGroup值的Wait方法，而被阻塞的时候
2. 另一个goroutine调用该值的Done方法，并使计数器的值变为0
3. 这会唤醒当前的goroutine，并使它试图继续执行Wait方法中其余的代码
4. 这时又有一个goroutine调用了它的Add方法，并让计数器的值又从0变成了某个正整数
5. **此时，这里的Wait方法就会立即抛出一个panic**

**WaitGroup使用禁忌**：不要把增加计数器值的操作和调用Wait方法的代码，放在不同的goroutine中执行。**杜绝同一个WaitGroup值的两种操作的并发执行**。

### sync.Once类型值的Do方法如何保证只执行参数函数一次

与`sync.WaitGroup`类型一样，`sync.Once`类型也属于结构体类型，同样也是开箱即用和并发安全的。由于这个类型中包含了一个`sync.Mutex`类型的字段，所以复制该类型的值也会导致功能的失效。

> Once类型的Do方法只接受一个参数，这个参数的类型必须是func()，即：无参数声明和结果声明的函数。该方法的功能并不是对每一种参数函数都只执行一次，而是只执行首次被调用时传入的那个函数，并且之后不会再执行任何参数函数。如果有多个只需执行一次的函数，为它们每个都分配一个`sync.Once`类型的值。

Once类型中还有一个叫done的unit32类型的字段，它的作用是记录其所属值的Do方法被调用的次数，该值只能是0或者1。一旦Do方法的首次调用完成，它的值就会从0变成1。

done字段虽然只有0或者1，但是使用了四字节的uint32类型：

1. 对这个字段的操作必须是原子的，Do方法在一开始就会通过调用`atomic.LoadUint32`函数来获取该字段的值，并且一点发现该值为1，就直接返回。**初步保证了Do方法，只会执行首次被调用时传入的函数**。
    > 如果两个goroutine都调用了同一个新的Once的Do方法，几乎同时执行条件判断代码，那么会因为判断结果为false而继续执行Do方法中剩余的代码。
2. 所以在条件判断之后，Do方法会立即所动其所属值中的那个`sync.Mutex`类型的字段m，然后，它会在临界区中再次检查done字段的值，并且仅在条件满足时，才会去调用参数函数，以及用原子操作把done的值变为1。

#### Do方法在功能方面的特点

1. Do方法只会在参数函数执行结束之后把done字段的值变为1，因此，如果参数函数的执行需要很长时间或者根本就不会结束（比如执行一些守护任务），那么就有可能会导致相关goroutine的同时阻塞。

2. Do方法在参数函数执行结束后，对done字段的复制用的是原子操作，并且，这一操作是被挂在defer语句中的，因此，不论参数函数的执行会以怎样的方式结束，done字段的值都会变为1。即使这个参数函数没有执行成功（引发了一个panic），我们也无法使用同一个once值重新执行它。如果需要为参数函数的执行设定重试机制，要考虑Once值的适时替换问题。

### 小结

sync包中的WaitGroup类型和Once类型都是非常易用的同步工具。它们都是开箱即用和并发安全的。

利用WaitGroup值，可以方便地实现一对多的goroutine协作流程，即：一个分发子任务的goroutine和多个执行子任务的goroutine，共同来完成一个较大的任务。

**使用WaitGroup值的时候，一定要注意，千万不能让其中的计数器的值小于0，否则就会引发panic**。我们最好用“**先统一Add，再并发Done，最后Wait**”这种标准方式，来使用WaitGroup值。尤其不要在调用Wait方法同时，并发地通过调用Add方法去增加其计数器的值，因为这也有可能引发panic。

Once值的使用比WaitGroup值更简单，只有一个Do方法，同一个Once值的Do方法永远只会执行第一次被调用时传入的参数函数，不论这个函数的执行会以怎么样的方式结束。

只要传入某个Do方法的参数函数没有结束执行，任何只会调用该方法的goroutine就会被阻塞。只有在这个参数函数执行结束一会，那些goroutine才会逐一被唤醒。

Once类型使用互斥锁和原子操作实现了功能，而WaitGroup类型中只用到了原子操作。它们都是更高级的同步工具，基于基本的通用工具，实现了某一种特定的功能。**sync包中的其他高级同步工具，都是这样实现的**。


