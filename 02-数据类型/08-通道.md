# 通道

> Don't communicate by sharing memory;share memory bu communicating. 不要通过共享内存来通信，而应该通过通信来共享内存。

通道与goroutine共同代表Go语言独有的并发编程模式和编程哲学，利用通道在多个goroutine之间传递数据。

**通道类型的值，本身就是并发安全的**。这是Go语言自带的唯一一个可以满足并发安全性的类型。

在声明并初始化一个通道的时候，需要使用Go内建函数`make()`,传给这个函数的第一个参数应该是代表了通道的具体类型的类型字面量，第二个参数是一个int类型的值，不能小于0，表示通道的容量（该参数可选）。

- 当容量为0时，表示这是一个非缓冲通道
- 当容量大于0时，表示缓冲通道

非缓冲通道和缓冲通道有不同的数据传递方式。

> 声明一个通道类型变量的时候，首先要确定该通道类型的元素类型，这决定了通过这个通道传递声明类型的数据。

```go
chan int
// chan 表示通道类型的关键字
// int 说明该通道类型的元素类型

ch1 := make(chan int,3)
```

**一个通道相当一个FIFO队列，通道中各个元素严格按照发送顺序排列，元素值的发送和接收都用到操作符`<-`,称为接送操作符，该符号形象的表示了元素值的传输方向**。

对发送与接收操作的基本特性：

1. 对同一个通道，发送操作之间是**互斥**的，接收操作之间也是**互斥**的
2. 发送操作和接收操作中对元素值的处理都是**不可分割**的
3. 发送操作和接收操作在完全完成之前会被阻塞

## 特性1

在同一时刻，Go语言运行时系统只会执行对同一个通道的任意个发送操作中的某一个。**直到这个元素值被完全复制进该通道之后，其他针对该通道的发送操作才可能被执行**。接收操作也是一样的，即使操作是并发执行的也是如此。

对于通道内的同一个元素值，发送操作和接收操作之间也是互斥的。即使一个正在被复制进通道但还未辅助完成的元素值，也绝不会被想接收它的一方看到和取走。

**元素值从外界进入通道时是被复制，即进入通道的并不是接收操作符右边的那个元素值，而是它的副本**。

元素从通道进入外界时会被移动：

1. 生成正在通道中的这个元素值的副本，并准备给到接收方
2. 删除在通道中的这个元素值

## 特性2

**不可分割**表示处理通道中元素的操作是一个原子操作：

1. 发送操作要么没复制值，要么已经复制完毕
2. 接收操作在主播好元素值副本之后，一定会删除掉通道中的原值，绝不会出现有残留的情况

## 特性3

发送操作：

1. 复制元素值
2. 放置副本到通道内部

接收操作：

1. 复制通道内的元素值
2. 放置副本到接收方
3. 删除原值

在所有步骤完全完成前，发起该操作的代码会一直阻塞，知道该代码所在goroutine收到了运行时系统的通知并重新获得运行机会为止。

**如此阻塞代码就是为了实现操作的互斥和元素值的完整**。

## 长时间阻塞的发送和接收操作

### 缓冲通道

1. 如果通道已满，对它的所有发送操作都会被阻塞，直到通道中有元素值被接收走，此时通道会优先通知最早因此而等待的那个发送操作所在的goroutine，然后再次执行发送操作。

> 由于发送操作在这种情况下被阻塞后，它们所在的goroutine会顺序地进入通道内部的发送等待队列，所以通知的顺序是公平的。

2. 如果通道已空，对它的所有接收操作都会被阻塞，直到通道中有新的元素出现，此时通道会优先通知最早等待的那个接收操作所在的goroutine，并使它再次执行接收操作。

> 因此而等待的所有接收操作所在的goroutine都会按照先后顺序被放入通道内部的接收等待队列。

缓冲通道作为收发双方的中间件，元素值先从发送方复制到缓冲通道，之后再由缓冲通道复制给接收方。**当发送操作在执行的时候发现空的通道中，正好有等待的接收操作，那么它会直接把元素值复制给接收方**。

### 非缓冲通道

无论是发送操作还是接收操作，一开始执行就会被阻塞，直到配对的操作也开始执行，才会继续传递。

> 非缓冲通道是在用同步的方式传递数据，只有收发双方对接上了，数据才会被传递。

数据直接从发送方复制到接收方，中间并没有非缓冲通道做中转，相比之下，缓冲通道则在用异步的方式传递数据。

### 错误使用通道

对值为nil的通道，不论它的具体类型是什么，对它的发送和接收操作都会永久地处于阻塞状态。它们所属的goroutine中的任何代码都不再会被执行。

> 通道类型是引用，所以它的零值就是nil，只声明该类型的变量但没有用`make()`函数对它初始化时，该变量的值就是nil。

## 引起panic的发送和接收操作

1. 对已关闭的通道进行**发送操作**（接收操作可以感知到通道已经关闭，并安全退出）
2. 关闭已经关闭的通道

接收操作返回两个值：

- 元素值
- 接收操作成功与否

**如果通道关闭时，里面有元素值未取出，接收操作会把通道中的值按顺序取值之后，在返回通道已关闭的false判断**。因此，通过接收操作的返回值的第二个值来判断通道是否关闭有延迟。

> 除非有特殊保证，否则让发送方关闭通道，而不是接收方。

## 单向通道

- 通常说的通道都是双向通道，可以发也可以收。
- 单向通道：只能发或者之只能收。

一个通道是双向还是单项，又类型字面量体现。

```go
var uselessChan = make(chan<- int,1)    // 发送通道，只能发（往通道中发送）

uselessChan = make(<-chan int,1)        // 接收通道，只能收（从通道中接收）
```

**站在操作通道的代码的角度，看单向通道是发送通道还是接收通道**。

### 单向通道的价值

**单向通道最主要的用途是约束其他代码的行为**。

**例子：**

```go
func SendInt(ch chan<- int) {
    ch <- rand.Intn(1000)
}
// SendInt函数，只能接受一个发送通道，函数中的代码只能向通道中发送元素值，而不能从通道中接收元素值
```

在实际场景中，约束一般出现在接口类型声明中的某个方法定义上，或者，声明函数类型时，如果使用单向通道，相当于约束所有实现这个函数类型的函数。**在编写模板代码或可扩展的程序库是很有用**。

```go
type Notifier interface {
    SendInt(ch chan<- int)
}
// 定义SendInt方法，参数是一个发送通道
// 该接口的所实现类型中的SendInt方法都受到限制

// 在调用SendInt函数时，只需要将一个双向通道作为参数传递给它，Go语言会自定把它转换为所需的单向通道
```

在接口类型声明的花括号中，每一行代表一个方法的定义。

> 接口中方法定义与函数声明很类似，只包含方法名，参数列表和结果列表。一个类型如果想要成为一个接口的实现类型，必须实现接口中定义的所有方法。**因此某个方法中定义了单向通道，那么相当于对它的所有实现做出约束**。

```go
func getIntChan() <-chan int {
    num := 5
    ch := make(chan int, num)
    for i := 0; i < num; i++ {
        ch <- i
    }
    close(ch)
    return ch
}

// 在函数的结果类别中使用单向通道
// 得到该通道的程序，只能从通道中接收元素值，这是对函数调用方法的一种约束

intChan2 := getIntChan()
for elem := range intChan2 {
    fmt.Printf("The element in intChan2: %v\n", elem)
}

// for语句循环的从单向通道中取出元素值
```

对上述for语句的解释：

1. for语句会不断尝试从initChan2取出元素值，及时通道被关闭，也会取出所有剩余的元素值之后在结束执行
2. 单向通道中没有元素值时，代码会被阻塞在for关键字那一行
3. initChan2的值为nil，代码会被永远阻塞在for关键字那一行

> 上述三点是带range子句的for循环与通道的联系，Go还有专门操作通道的select语句。

## select语句

select语句只能与通道联用，一般由若干个分支组成，每次执行select语句的时候，只有一个分支中的代码会被执行。

select语句的分支：

1. 候选分支：以关键字`case`开头，后面是一个case表达式和一个冒号，从下一行开始写入，分支被选中时需要执行的语句
2. 默认分支：`default case`，**当且仅当**没有候选分支被选中时，它才会被执行，default开头后面直接是冒号，从下一行开始写入要执行的语句

> select语句是专门为通道而设计的，每个case表达式中只能包含操作通道的表达式，如接收表达式。

**例子：**

```go
// 准备好几个通道。
intChannels := [3]chan int{
    make(chan int, 1),
    make(chan int, 1),
    make(chan int, 1),
}

// 随机选择一个通道，并向它发送元素值。
index := rand.Intn(3)
fmt.Printf("The index: %d\n", index)
intChannels[index] <- index

// 哪一个通道中有可取的元素值，哪个对应的分支就会被执行。
select {
case <-intChannels[0]:
    fmt.Println("The first candidate case is selected.")
case <-intChannels[1]:
    fmt.Println("The second candidate case is selected.")
case elem := <-intChannels[2]:
    fmt.Printf("The third candidate case is selected, the element is %d.\n", elem)
default:
    fmt.Println("No candidate case is selected!")
}
```

select语句的注意点：

1. 设置默认分支后，无论涉及通道操作的表达式是否有阻塞，select语句都不会被阻塞。
2. 如果没有默认分支，一旦所有case表达式都没有满足求值条件，那么select语句就会被阻塞，直到至少有一个case表达式满足条件为止。
3. 当通道关闭后，会从通道中接收到其元素类型的零值，所以需要接收表达式的第二个结果值来判断通道是否关闭。一旦发现某个通道关闭了，应该及时屏蔽对应的分支或采取其他措施。
4. select语句只能对其中的每一个case表达式各求值一次。如果连续或定时地操作其中的通道，就需要通过for语句中嵌入select语句的方式实现。简单地在select语句的分支中使用break语句，只能结束当前的select语句的执行，而并不会对外层的for语句产生作用。这种错误的用法可能会让这个for语句无休止的运行下去。如下面的例子。

```go
intChan := make(chan int, 1)
// 一秒后关闭通道。
time.AfterFunc(time.Second, func() {
    close(intChan)
})
select {
case _, ok := <-intChan:
    if !ok {
        fmt.Println("The candidate case is closed.")
        break
    }
    fmt.Println("The candidate case is selected.")
}
```

### 分支选择规则

1. 每一个case表达式，至少有一个发送或接收操作，也可以包含其他的表达式。多个表达式从左到右顺序被求值。
2. select语句包含的候选分支中的case表达式会在该语句执行时先被求值，求值顺序从代码编写的顺序从上往下，所有分支都会被求值，从上到下，从左往右。
3. case表达式中的发送或接收操作处于阻塞状态时，该case表达式的求值就不成功，即候选分支不满足条件。
4. 只有当所有case表达式都被求值完成后，才开始选择候选分支。只会挑选满足条件的候选分支执行。
   1. 所有候选分支都不满足条件，选择默认分支
   2. 没有默认分支，select语句处于阻塞状态，直到至少有一个候选分支满足条件为止
5. 如果同时有多个候选分支满足条件，用伪随机算法在候选分支中选择一个，然后执行。
6. 一个select语句只有一个默认分支，并且默认分支只在无候选分支可选的时候才会执行，与编写位置无关。
7. select语句的每次执行，包括case表达式求值和分支选择都是独立的，它的执行是否并发安全，要看其中的case表达式以及分支中是否包含并发不安全的代码。
