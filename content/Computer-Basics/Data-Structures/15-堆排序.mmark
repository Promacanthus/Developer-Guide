---
title: "15 堆排序"
date: 2020-07-01T16:20:52+08:00
draft: true
---

堆是一种特殊的数据结构，应用场景很多，堆排序是一种原地排序，时间复杂度`O(nlogn)`。

## 堆

堆是一种特殊的树，满足以下两点就是一个堆：

- 堆是一个完全二叉树（除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列）

- 堆中每一个节点的值都必须大于等于（或小于等于）其左右子节点的值
  - 对于每个节点的值都**大于等于**子树中每个节点值的堆，叫作“大顶堆”
  - 对于每个节点的值都**小于等于**子树中每个节点值的堆，叫作“小顶堆”

### 实现堆

#### 存储方式

堆是完全二叉树比较适合用**数组**来存储。用数组来存储完全二叉树是非常节省存储空间的。因为不需要存储左右子节点的指针，单纯地通过数组的下标，就可以找到一个节点的左右子节点和父节点。

![image](/images/4d349f57947df6590a2dd1364c3b0b1e.jpg)

从图中可以看到，数组中下标为 `i` 的节点：

- 左子节点：是下标为 `i∗2` 的节点
- 右子节点：是下标为 `i∗2+1` 的节点
- 父节点：是下标为 $$\frac{i}{2}$$​ 的节点

#### 往堆中插入一个元素

如果往堆尾插入一个元素后，需要继续满足堆的两个特性，这时就需要进行调整，称为**堆化**。堆化有两种：

- 从下往上
- 从上往下

> 堆化非常简单，就是顺着节点所在的路径，向上或者向下，对比，然后交换。

下面的例子是从下往上的堆化。

![image](/images/e578654f930002a140ebcf72b11eb722.jpg)

1. 新插入的节点与父节点对比大小
2. 如果不满足子节点小于等于父节点的大小关系，就互换两个节点
3. 一直重复这个过程，直到父子节点之间满足刚说的那种大小关系

![image](/images/e3744661e038e4ae570316bc862b2c0e.jpg)

#### 删除堆顶元素

根据堆的定义，任何节点的值都大于等于（或小于等于）子树节点的值，所以，堆顶元素存储的就是堆中数据的最大值或者最小值。

假设构造的是大顶堆，堆顶元素就是最大的元素。

1. 当删除堆顶元素后，就需要把第二大的元素放到堆顶
2. 第二大元素肯定会出现在左右子节点中
3. 然后再迭代地删除第二大节点
4. 以此类推
5. 直到叶子节点被删除

![image](/images/5916121b08da6fc0636edf1fc24b5a81.jpg)

出现左侧叶子节点为空的情况，这样的删除思路导致堆不满足完全二叉树的特性。

换一下思路来解决这个问题。

1. 当删除堆顶元素后，把最后一个节点放到堆顶
2. 然后利用同样的父子节点对比方法
3. 对于不满足父子节点大小关系的，互换两个节点
4. 并且重复进行这个过程，直到父子节点之间满足大小关系为止

这就是**从上往下**的堆化方法。

> 因为移除的是数组中的最后一个元素，而在堆化的过程中，都是交换操作，不会出现数组中的“空洞”，所以这种方法堆化之后的结果，肯定满足完全二叉树的特性。

![image](/images/110d6f442e718f86d2a1d16095513260.jpg)

一个包含 `n` 个节点的完全二叉树，树的高度不会超过 $$log_2​n$$。堆化的过程是顺着节点所在路径比较交换的，所以堆化的时间复杂度跟树的高度成正比，也就是 $$O(logn)$$。

插入数据和删除堆顶元素的主要逻辑就是**堆化**，所以，往堆中插入一个元素和删除堆顶元素的时间复杂度都是 $$O(logn)$$。

## 基于堆实现排序

借助于堆这种数据结构实现的排序算法，就叫作**堆排序**，它的时间复杂度非常稳定，是 $$O(nlogn)$$，并且它还是原地排序算法。把堆排序的过程大致分解成两个大的步骤，**建堆**和**排序**。

### 建堆

首先将数组原地建成一个堆。所谓“原地”就是，不借助另一个数组，就在原数组上操作。建堆的过程，有两种思路。

1. 第一种是按照在堆中插入一个元素的思路。假设起初堆中只包含一个数据，就是下标为 1 的数据。然后，调用插入操作，将下标从 2 到 n 的数据依次插入到堆中。这样就将包含 n 个数据的数组，组织成了堆。这种建堆思路的处理过程是：
   1. **从前往后**处理数组数据
   2. 并且每个数据都是**从下往上**堆化
2. 第二种实现思路，跟第一种截然相反：
   1. **从后往前**处理数组
   2. 并且每个数据都是**从上往下**堆化

举个例子操作第二种实现思路的建堆分解步骤图。因为叶子节点往下堆化只能自己跟自己比较，所以直接从**第一个非叶子节点**开始，依次堆化就行了。

![image](/images/50c1e6bc6fe68378d0a66bdccfff441e.jpg)

![image](/images/aabb8d15b1b92d5e040895589c60419d.jpg)

对于完全二叉树来说，下标从 $$\frac{n}{2}+1$$ 到 n 的节点都是叶子节点，不需要参与堆化的过程，所以对下标从 $$\frac{n}{2}$$ 开始到 1 的数据进行堆化。

每个节点堆化的时间复杂度是 `O(logn)`，$$\frac{n}{2}+1$$个节点堆化的总时间复杂度就是`O(nlogn)`，跟精确一点，堆排序的建堆过程的时间复杂度是 `O(n)`。

因为叶子节点不需要堆化，所以需要堆化的节点从倒数第二层开始。每个节点堆化的过程中，需要比较和交换的节点个数与该节点的高度 k 成正比。

![image](/images/899b9f1b40302c9bd5a7f77f042542d5.jpg)

将每个非叶子节点的高度求和：

![image](/images/f712f8a7baade44c39edde839cefcc09.jpg)

把公式左右都乘以 2，就得到另一个公式 S2，将 S2 错位对齐，并且用 S2 减去 S1，可以得到 S。

![image](/images/629328315decd96e349d8cb3940636df.jpg)

S 的中间部分是一个等比数列，所以最后可以用等比数列的求和公式来计算。

![image](/images/46ca25edc69b556b967d2c62388b7436.jpg)

因为 $$h=log2_​n$$，代入公式 S，就能得到 `S=O(n)`，所以，建堆的时间复杂度就是 `O(n)`。

### 排序

建堆结束之后，数组中的数据已经是按照大顶堆的特性来组织的。数组中的第一个元素就是堆顶，也就是最大的元素。

1. 把堆顶元素跟最后一个元素交换，那最大元素就放到了下标为 n 的位置，然后开始堆化。
  
  > 这个过程类似“删除堆顶元素”的操作，当堆顶元素移除之后，把下标为 n 的元素放到堆顶，然后再通过堆化的方法，将剩下的 n−1 个元素重新构建成堆。

2. 堆化完成之后，再取堆顶的元素，放到下标是 n−1 的位置
3. 一直重复这个过程
4. 直到最后堆中只剩下标为 1 的一个元素，排序工作就完成了

![image](/images/23958f889ca48dbb8373f521708408d1.jpg)

整个堆排序的过程，都只需要极个别临时存储空间，所以堆排序是**原地排序算法**。

堆排序包括建堆和排序两个操作，建堆过程的时间复杂度是 `O(n)`，排序过程的时间复杂度是 `O(nlogn)`，所以，堆排序整体的时间复杂度是 `O(nlogn)`。

堆排序是**不稳定排序算法**，因为在排序的过程，存在将堆的最后一个节点跟堆顶节点互换的操作，所以就有可能改变值相同数据的原始相对顺序。

上面都是假设，堆中的数据是从数组下标为 `1` 的位置开始存储。那如果从 `0` 开始存储，实际上处理思路是没有任何变化的，唯一变化的，可能就是，代码实现的时候，计算子节点和父节点的下标的公式改变了。

如果节点的下标是 `i`，那左子节点的下标就是 `2∗i+1`，右子节点的下标就是 `2∗i+2`，父节点的下标就是 `2i−1`​。

### 应用

在实际开发中，快速排序要比堆排序性能好：

1. 堆排序数据访问的方式没有快速排序友好
   1. 对于快速排序来说，数据是顺序访问的（对CPU友好）
   2. 对于堆排序来说，数据是跳着访问的（堆排序中，最重要的一个操作就是数据的堆化）
2. 对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序

> 对于基于比较的排序算法来说，整个排序过程就是由两个基本的操作组成的，**比较**和**交换**（或移动）。

堆排序的第一步是建堆，建堆的过程会打乱数据原有的相对先后顺序，导致原数据的有序度降低。比如，对于一组已经有序的数据来说，经过建堆之后，数据反而变得更无序了。
