---
title: "07 排序"
date: 2020-06-22T09:37:00+08:00
draft: true
---

## 分析排序算法

### 执行效率

对于排序算法执行效率的分析，一般会从这几个方面来衡量：

1. 最好情况、最坏情况、平均情况时间复杂度（最好、最坏情况对应的待排序原始数据是什么样的？）：**有序度**不同的数据，对排序的执行时间有影响
2. 时间复杂度的系数、常数 、低阶：实际开发中，待排序的数据规模是 10/100/1000 这样的小规模，所以，在对同一阶时间复杂度的排序算法性能对比时，要把系数、常数、低阶也考虑进来
3. 比较次数和交换（或移动）次数：基于**比较**的排序算法的执行过程，会涉及元素比较和元素交换/移动的操作。所以，在分析排序算法的执行效率的时候，应该把比较次数和交换（或移动）次数也考虑进去

### 内存消耗

算法的内存消耗通过空间复杂度来衡量，针对排序算法的空间复杂度，要引入了一个新的概念，**原地排序**（Sorted in place），原地排序算法，就是特指空间复杂度是 `O(1)` 的排序算法。

### 稳定性

仅仅用**执行效率**和**内存消耗**来衡量排序算法的好坏是不够的。针对排序算法，还有一个重要的度量指标，**稳定性**（如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变）。

排序算法是否稳定的影响，主要是在实际的软件开发中，使用对象的某个`key`来排序而非一个整数（key的先后顺序有实际的业务意义，而一个整数的先后顺序没有影响）。看下面具体的例子来感受一下。

现在要给电商交易系统中的“订单”排序。订单有两个属性：

- 下单时间，
- 订单金额。

排序的需求：

1. 现在有 10 万条订单数据，按照金额从小到大对订单数据排序
2. 对于金额相同的订单，按照下单时间从早到晚有序

最先想到的方法是：

1. 先按照金额对订单数据进行排序
2. 再遍历排序之后的订单数据，对于每个金额相同的小区间按照下单时间排序

这种排序思路理解起来不难，但是实现起来会很复杂。借助稳定排序算法，这个问题可以非常简洁地解决。

解决思路是这样的：

1. 先按照下单时间（注意是按照下单时间，不是金额）给订单排序
2. 排序完成之后，用稳定排序算法，按照订单金额重新排序

两遍排序之后，得到的订单数据就是按照金额从小到大排序，金额相同的订单按照下单时间从早到晚排序的。

因为，稳定排序算法可以保持金额相同的两个对象，在排序之后的前后顺序不变。

1. 第一次排序之后，所有的订单按照下单时间从早到晚有序
2. 在第二次排序中，使用稳定排序算法，经过第二次排序之后，相同金额的订单仍然保持下单时间从早到晚有序

![image](/images/1381c1f3f7819ae61ab17455ed7f0b59.jpg)

## 常见排序算法

### 冒泡排序

冒泡排序只会操作**相邻**的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。**一次冒泡会让至少一个元素移动到它应该在的位置**，重复 n 次，就完成了 n 个数据的排序工作。

假设待排序数据为`4,5,6,3,2,1`，从小到大进行排序，第一次冒泡的详细过程如下图：

![image](/images/4038f64f47975ab9f519e4f739e464e9.jpg)

要完成所有数据的排序，需要进行6次冒泡操作：

![image](/images/9246f12cca22e5d872cbfce302ef4d09.jpg)

将上述冒泡过程进行优化，当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再执行冒泡操作，如下示例：
![image](/images/a9783a3b13c11a5e064c5306c261e8e6.jpg)

1. 在冒泡的过程，只涉及相邻数据的交换操作，只需要常量级的临时空间，空间复杂度为 `O(1)`，是**原地排序算法**。
2. 在冒泡的过程中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，不做交换，相同大小的数据在排序前后不会改变顺序，是**稳定排序算法**。
3. 时间复杂度：
   1. 最好情况，待排序数据有序（满有序度），只需要进行一次冒泡，时间复杂度是`O(n)`
   2. 最坏情况，待排序数据倒序（有序度为0），要进行n次冒泡，时间复杂度是`O(n^2)`
   3. 平均情况，根据数据初始的有序度假设为满有序度的一般即`n*(n-1)/4`，时间复杂度是`O(n^2)`

#### 有序度

**有序度**是数组中具有有序关系的元素对的个数。有序元素对用数学表达式表示：`a[i] <= a[j], 如果i < j`
**逆序度**的定义正好跟有序度相反（默认从小到大为有序）：`a[i] > a[j], 如果i < j`

**逆序度 = 满有序度 - 有序度**。排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度，就说明排序完成了。

如`{2,4,3,1,5,6}`的有序度是11，`{6,5,4,3,2,1}`的有序度是0。

冒泡排序包含两个操作原子，**比较**和**交换**。每交换一次，有序度就加 1。

不管算法怎么改进，交换次数总是确定的，即为逆序度，也就是`n*(n-1)/2` – 初始有序度。

### 插入排序

使用动态排序向一个已经有序的数据集合中添加数据，插入后依然保持数据有序，即遍历数组，找到数据应该插入的位置将其插入即可。

对于一组静态数据（即数据集合的元素个数不变），借助上面的思想实现插入排序。

1. 将数组中的数据分为两个区间，**已排序区间**和**未排序区间**
2. 初始已排序区间只有一个元素，就是数组的第一个元素。
3. 插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。
4. 重复这个过程，直到未排序区间中元素为空，算法结束。

假设有待排序数据为`4,5,6,3,2,1`，左侧为已排序区间，右侧为未排序区间。

![image](/images/b60f61ec487358ac037bf2b6974d2de1.jpg)

插入排序也包含两种操作，：

- 元素的比较
- 元素的移动

当需要将一个数据 `a` 插入到已排序区间时，需要拿 `a` 与已排序区间的元素依次比较大小，找到合适的插入位置。找到插入点之后，需要将插入点之后的元素顺序往后移动一位，这样才能腾出位置给元素 `a` 插入。

> 对于不同的查找插入点方法（从头到尾、从尾到头），元素的比较次数是有区别的。但**对于一个给定的初始序列，移动操作的次数总是固定的，就等于逆序度**。

1. 插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 `O(1)`，是**原地排序算法**
2. 在插入排序中，对于值相同的元素，可以将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是**稳定排序算法**
3. 时间复杂度
   1. 最好情况，待排序数据有序（满有序度），只需从尾到头遍历一遍有序数据，时间复杂度是`O(n)`
   2. 最坏情况，待排序数据倒序（有序度为0），则每次插入都相当于在数组的第一个位置插入新的数据，时间复杂度是`O(n^2)`
   3. 平均情况，（数组这种数据结构插入数据的平均时间复杂度是`O(n)`）对于插入排序来说，每次插入操作都相当于在数组中插入一个数据，循环执行 n 次插入操作，所以平均时间复杂度是`O(n^2)`

### 选择排序

选择排序算法的实现思路有点类似插入排序，也分**已排序区间**和**未排序区间**。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。

1. 选择排序算法运行过程中不需要额外的空间，空间复杂度为 `O(1)`，是**原地排序算法**。
2. 在选择排序中，对于值相同的元素，选择先出现的值为最小值，这样就可以保持原有的前后顺序不变，但是，最小值会和前面的数据交换位置，这会导致其他的相同值的位置改变，所以选择排序是**不稳定排序算法**
3. 时间复杂度：
   1. 最好情况，待排序数据有序（满有序度），每个数据都要与数据集合中剩下的数据进行比较，时间复杂度`O(n^2)`
   2. 最坏情况，待排序数据倒序（有序度为0），每个数据都要与数据集合中剩下的数据进行比较，时间复杂度`O(n^2)`
   3. 平均情况，对选择排序来说，没有最好最坏情况，所有数据都要进行比较，时间复杂度`O(n^2)`

### 插入比冒泡更受欢迎

冒泡排序和插入排序的时间复杂度都是 `O(n^2)`，都是**原地排序算法**：

- 冒泡排序不管怎么优化，元素交换的次数是一个固定值，是**原始数据的逆序度**
- 插入排序不管怎么优化，元素移动的次数是一个固定值，是**原始数据的逆序度**

从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。

```go
// 冒泡排序中数据的交换操作：
if (a[j] > a[j+1]) { // 交换
   int tmp = a[j];
   a[j] = a[j+1];
   a[j+1] = tmp;
   flag = true;
}

// 插入排序中数据的移动操作：
if (a[j] > value) {
  a[j+1] = a[j];  // 数据移动
} else {
  break;
}
```

把执行一个赋值语句的时间粗略地计为单位时间（`unit_time`），然后分别用冒泡排序和插入排序对同一个逆序度是 K 的数组进行排序。

- 冒泡排序，需要 K 次交换操作，每次需要 3 个赋值语句，所以交换操作总耗时就是 `3*K` 单位时间。
- 插入排序，数据移动操作只需要 K 个单位时间。

```golang
// 测试数据集合 []int{4, 5, 1, 6, 2, 3, 4, 5, 1, 6, 2, 3, 4, 5, 1, 6, 2, 3}

// 冒泡排序，每秒调用6659475次
goos: linux
goarch: amd64
pkg: deal/sort
BenchmarkBubbleSort
BenchmarkBubbleSort-4     6659475        183 ns/op
PASS

// 插入排序，每秒调用11622802次
goos: linux
goarch: amd64
pkg: deal/sort
BenchmarkInsertionSort
BenchmarkInsertionSort-4    11622802         99.2 ns/op
PASS
```

实际结果相差两倍，所以，虽然冒泡排序和插入排序在时间复杂度上是一样的，都是 `O(n^2)`，但是如果希望把性能优化做到极致，那肯定首选**插入排序**，**它的算法思路也有很大的优化空间**，如[希尔排序](https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F)。

### 三者对比

特定算法依赖特定的数据结构，这三种算法都依赖数组实现。

|算法|是否原地排序|是否稳定|最好|最坏|平均|
---|---|---|---|---|---
冒泡|Y|Y|`O(n)`|`O(n^2)`|`O(n^2)`
插入|Y|Y|`O(n)`|`O(n^2)`|`O(n^2)`
选择|Y|N|`O(n^2)`|`O(n^2)`|`O(n^2)`

冒泡排序、插入排序、选择排序这三种排序算法，它们的平均时间复杂度都是 `O(n^2)`，比较高，适合**小规模数据**的排序。下面是两种时间复杂度为 `O(nlogn)` 的排序算法，归并排序和快速排序，都用到了分治的思想，适合**大规模数据**排序。

### 归并排序

归并排序的核心思想是：

1. 先把数组从中间分成前后两部分
2. 然后对前后两部分分别排序
3. 再将排好序的两部分合并在一起，这样整个数组就都有序了

![image](/images/db7f892d3355ef74da9cd64aa926dc2b.jpg)

归并排序使用的就是分治思想，将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。

> 分治思想和递归思想很像，**分治算法一般都是用递归来实现**。**分治是一种解决问题的处理思想，递归是一种编程技巧**，这两者并不冲突。

归并排序使用分治思想，用递归实现：

1. 分析递推公式：`MergeSort(m...n)=merge(mergeSort(m...q)+mergeSort(q+1...n)),q=(p+r/2)`
2. 找到终止条件：`m>=n`
3. 将递推公式翻译成递归代码

在递推公式中，`mergeSort（）`函数是被分解后的子问题，`merge()`函数是将已经有序的前后两部分合并为一个整体有序的数据集合，具体过程如下：

1. 在函数内申请一个临时数组，
2. 分别从头开始比较已经有序的前后两部分，
3. 将较小的那一个先放入临时数组中，
4. 继续整个过程直到一个子数组中没有数据
5. 将剩下的数组中全部数据直接插入临时数组末尾
6. 将临时数组中的数据拷贝到原数组中

#### 性能分析

1. 归并排序稳不稳定关键要看 `merge()` 函数，即两个有序子数组合并成一个有序数组的那部分代码，可以保证值相同的元素，在合并前后的先后顺序不变，是**稳定排序算法**。

2. 递归的是时间复杂度公式：`T(a) = T(b) + T(c) + K`，其中 `K` 等于将两个子问题 `b`、`c` 的结果合并成问题 `a` 的结果所消耗的时间。所以归并排序的时间复杂度的计算公式是：

   ```bash
   # n=1时，只需要常量级的执行时间，所以表示为C。
   T(1) = C

   # n>1
   T(n) = 2*T(n/2) + n；

   # 继续分解
   T(n) = 2*T(n/2) + n
      = 2*(2*T(n/4) + n/2) + n = 4*T(n/4) + 2*n
      = 4*(2*T(n/8) + n/4) + 2*n = 8*T(n/8) + 3*n
      = 8*(2*T(n/16) + n/8) + 3*n = 16*T(n/16) + 4*n
      ......
      = 2^k * T(n/2^k) + k * n
      ......

   # 得到结果
   T(n) = 2^k ×　T(n/2^k)　+　kn
   # 当ｎ＝１时
   T(n/2^k)=T(1)
   n/2^k=1
   k=log2n

   # 将ｋ带入公式
   T(n)=Cn+nlog2n
   ```

   归并排序的执行效率与要排序的原始数组的有序程度无关，所以其时间复杂度是非常稳定的，不管是最好情况、最坏情况，还是平均情况，时间复杂度都是 `O(nlogn)`。

   **不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写成递推公式**。

3. 在`merge()`函数中，创建了一个临时数据（额外申请的临时内存空间）用于存储中间结果。因此，归并排序不是原地排序算法，空间复杂度是`O(n)`。因为，尽管每次合并操作都需要申请额外的内存空间，但在合并完成之后，临时开辟的内存空间就被释放掉了。在任意时刻，CPU 只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时内存空间最大也不会超过 n 个数据的大小。

### 快速排序
