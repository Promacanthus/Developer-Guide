---
title: 05-数组和切片.md
date: 2019-11-25T11:15:47.522182+08:00
draft: false
hideLastModified: false
summaryImage: ""
keepImageRatio: true
tags:
- ""
- Go语言
- 基础
summary: 05-数组和切片.md
showInMenu: false

---

# 数组和切片

- 共同点：都属于集合类的类型，可以存储某一种类型的值；应用索引表达式得到值，应用切片表达式得到新切片。
- 不同点：数组的值长度固定，切片的值可变长

**数组的长度必须在声明时给定，且不可变，它是数组类型的一部分**。

**切片的类型字面量中，只有元素类型，长度随着元素数量增长而增长，但不会减小**。

> 切片可以看成是对数组的一层简单封装，在每个切片的底层数据结构中，一定会包含一个数组。

- 数组：是切片的底层数组
- 切片：是对数组的某个连续片段的引用，切片的容量代表了其可见底层数组的长度，切片的底层数组长度不可变

## 引用类型与值类型

引用类型：

1. 切片类型（切片是对数组某个连续片段的引用）
2. 字典类型
3. 通道类型
4. 函数类型

值类型：

1. 基础数据类型
2. 结构体类型
3. 数组类型

> Go语言中不存在“传值或传引用”的问题，在Go语言中只要看**被传递的值的类型**，如果被传递的值是引用类型，那就是“传引用”，如果被传递的值是值类型，那就是“传值”。从传递成本的角度，引用类型的值比值类型的值成本低很多。

## 内建函数

- len()：得到数组或切片的**长度**
- cap()：得到数组或切片的**容量**
- make(): 创建切片等

**数组容量永远和长度相等，且不可变**。

```go
// usage of make()

make(types interface{},length int,capacity int)

// types:要创建的类型
// length：该类型的长度
// capacity：该类型的容量

```

## 切片与底层数组的对应关系

```go
// make函数或切片值字面量初始化时，切片最左边与底层数组最左边对应
slice1 := make([]int,3,5)
sliec2 := []int{1,2,3,4,5,6,7,8}

// 切片表达书创建切片时,切片最左边与底层数组索引对应，slice3的最左边对应slice2的索引3
slice3 := slice2[3:6]
// slice3的容量为可见底层数组的容量，即底层数组减去切片起始索引值

// slice3向右扩展至最大
slice3 = slice3[0:cap(slice3)]
```

切片表达式是一个开区间，得到的新切片的容量和长度为区间的差值。新切片的起始值为原切片或数组对应的索引值。

切片无法向左扩展，但是可以向右扩展。

## 切片扩容

当切片无法容纳更多元素时，Go用语言会进行扩容，不会改变原切片，而是创建一个容量更大的新切片，将原来的元素和新的元素一起拷贝到新的切片中。

一般情况扩容2倍，当原切片的长度大于等于1024后，一次增长1.25倍的方式逐渐扩容。

## 切片底层数组被替换的情况

切片在扩容时，创建了新的切片和新的底层数组，原来的切片和底层数组没有任何改动。

1. 在底层数组容量（即切片容量）足够的情况下`append()`函数返回的是指向**原底层数组**的切片
2. 在底层数组容量（即切片容量）不够的情况下`append()`函数返回的是指向**新底层数组**的新切片
