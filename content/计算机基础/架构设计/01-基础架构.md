---
title: "01 基础架构"
date: 2020-06-01T16:44:09+08:00
draft: true
---

架构设计相关的特性：

1. 架构设计的思维和程序设计的思维差异很大。**架构设计的关键思维是判断和取舍，程序设计的关键思维是逻辑和实现**。
2. 架构设计没有体系化的培训和训练机制。
3. 程序员对架构设计的理解存在很多误区。

## 架构定义

### 系统与子系统

> 系统泛指由一群有**关联**的个体组成，根据某种**规则**运作，能完成个别元件不能单独完成的工作的群体。

1. **关联**：系统是由一群有关联的个体组成的，没有关联的个体堆在一起不能成为一个系统。
2. **规则**：系统内的个体需要按照指定的规则运作，而不是单个个体各自为政。规则规定了系统内个体分工和协作的方式。
3. **能力**：系统能力与个体能力有本质的差别，系统能力不是个体能力之和，而是产生了新的能力。

> 子系统是由一群有关联的个体所组成的系统，多半会是更大系统中的一部分。

### 模块与组件

> 软件模块（Module）是一套一致而互相有紧密关连的软件组织。它分别包含了程序和数据结构两部分。现代软件开发往往利用模块作为合成的单位。

**模块和组件都是系统的组成部分，只是从不同的角度拆分系统而已**。

- 从**逻辑**的角度来拆分系统后，得到的单元就是“模块”；划分模块的主要目的是**职责分离**。
- 从**物理**的角度来拆分系统后，得到的单元就是“组件”；划分组件的主要目的是**单元复用**，组件是独立独立可替换的。

### 框架与架构

> 软件框架（Software framework）通常指的是为了实现某个业界标准或完成特定基本任务的软件组件规范，也指为了实现某个软件组件规范时，提供规范所要求之基础功能的软件产品。

1. 框架是组件规范
2. 框架提供基础功能的产品

> 软件架构指软件系统的“基础结构”，创造这些基础结构的准则，以及对这些结构的描述。

**框架（Framework）关注的是“规范”，架构（Architecture）关注的是“结构”**。

### 架构

**软件架构指软件系统的顶层结构**。

- 架构是顶层设计；
- 框架是面向编程或配置的半成品；
- 组件是从技术维度上的复用；
- 模块是从业务维度上职责的划分；
- 系统是相互协同可运行的实体。

## 架构的目的

### 架构设计的误区

1. 因为架构很重要，所以要做架构设计
2. 不是每个系统都要做架构设计吗
3. 公司流程要求系统开发过程中必须有架构设计
4. 为了高性能、高可用、可扩展，所以要做架构设计

### 架构设计的真正目的

整个软件技术发展的历史，其实就是一部与“复杂度”斗争的历史。架构也是为了应对软件系统复杂度而提出的一个解决方案，**架构设计的主要目的是为了解决软件系统复杂度带来的问题**。

架构过程：

1. 通过熟悉和理解需求，识别**系统复杂性**所在的地方，然后针对这些复杂点进行架构设计。
2. 架构设计并不是要面面俱到，不需要每个架构都具备高性能、高可用、高扩展等特点，而是要识别出**复杂点**然后有针对性地解决问题。
3. 理解每个架构方案背后所需要解决的**复杂点**，然后才能对比自己的业务复杂点，参考复杂点相似的方案。

复杂度的六个来源：

1. 高性能
2. 高可用
3. 可扩展性
4. 低成本
5. 安全
6. 规模

## 高性能

软件系统中高性能带来的复杂度主要体现在两方面：

1. 一方面是单台计算机**内部**为了高性能带来的复杂度；
2. 另一方面是多台计算机**集群**为了高性能带来的复杂度。

### 单机复杂度

计算机内部复杂度最关键的地方就是**操作系统**，计算机性能的发展本质上是由**硬件**发展驱动的，尤其是 CPU 的性能发展。而将硬件性能充分发挥出来的关键就是操作系统，所以操作系统本身也是随硬件的发展而发展的，操作系统是软件系统的运行环境，**操作系统的复杂度直接决定了软件系统的复杂度**。

操作系统和性能最相关的就是**进程**和**线程**。

- 进程：用进程来对应一个操作系统执行的任务，每个任务都有自己独立的内存空间，进程间互不相关，由操作系统来进行调度。

- 多进程：为了达到多进程并行运行的目的，采取了分时的方式，即把 CPU 的时间分成很多片段，每个片段只能执行某个进程中的指令。

- 进程间通信：为了解决进程在运行时相互通信的问题，进程间通信的各种方式被设计出来了，包括管道、消息队列、信号量、共享存储等。

- 多线程：多进程让多任务能够并行处理任务，但本身还有缺点，**单个进程内部只能串行处理**，而实际上很多进程内部的子任务并不要求是严格按照时间顺序来执行的，也需要并行处理。为了解决这个问题发明了线程，**线程是进程内部的子任务**，但这些子任务都共享同一份进程数据。为了保证数据的正确性，又发明了互斥锁机制。有了多线程后，操作系统调度的最小单位就变成了线程，而进程变成了操作系统分配资源的最小单位。

- 多核处理器：多进程多线程虽然让多任务并行处理的性能大大提升，但本质上还是分时系统，并不能做到时间上真正的并行。解决这个问题的方式显而易见，就是让多个 CPU 能够同时执行计算任务，从而实现真正意义上的多任务并行。

    > 目前这样的解决方案有 3 种：
    >
    > 1. SMP（Symmetric Multi-Processor，对称多处理器结构），最常见，主流的多核处理器方案
    > 2. NUMA（Non-Uniform Memory Access，非一致存储访问结构）
    > 3. MPP（Massive Parallel Processing，海量并行处理结构）

操作系统发展到现在，如果要完成一个高性能的软件系统，需要考虑如**多进程**、**多线程**、**进程间通信**、多**线程并发**等技术点，而且这些技术并不是最新的就是最好的，也不是非此即彼的选择。

在做架构设计的时候，需要花费很大的精力来结合业务进行分析、判断、选择、组合，这个过程同样很复杂。例如，下面的系统都实现了高性能，但是内部实现差异很大：

- `Nginx` 可以用多进程也可以用多线程
- `JBoss` 采用的是多线程
- `Redis` 采用的是单进程
- `Memcache` 采用的是多线程

### 集群复杂度

让多台机器配合起来达到高性能的目的，是一个复杂的任务，常见的方式有：

> 任务可以指完整的业务处理，也可以指某个具体的任务。

1. 任务分配：每台机器都可以处理完整的业务任务，不同的任务分配到不同的机器上执行。
2. 任务分解：业务越来越复杂，单台机器处理的性能会越来越低。为了能够继续提升性能，采用任务分解。

#### 任务分配

![image](/images/b83913fb5a0358fec1be9b0af6ce4c60.png)

- 增加一个任务分配器，可以是硬件（F5、交换机）、软件（LVS）、负载均衡软件（Nginx、HAProxy）、自己开发的系统。
- 任务分配器与业务服务器之间的连接和交互。
- 任务分配器增加分配算法（轮询、权重、负载）。

业务量继续提升，需要增加任务分配器的数量。

![image](/images/67bfe499137fcb81c639be1a859c98a1.png)

- 任务分配器增加为多台，这样需要将不同的用户请求分配到不同的任务分配器上（DNS轮询、智能DNS、CDN、GSLB全局负载均衡）。
- 任务分配器和业务服务器之间从一对多变成多对多的网状结构。
- 业务服务器继续扩增，状态管理和故障处理复杂度更大。

#### 任务分解

> 微服务架构。

通过任务分配的方式，能够突破单台机器处理性能的瓶颈，通过增加更多的机器来满足业务的性能需求，但如果业务本身也越来越复杂，单纯只通过任务分配的方式来扩展性能，收益会越来越低。

![image](/images/fd36126477cdd76cfbc58367784aeffc.png)

通过这种任务分解的方式，能够把原来大一统但复杂的业务系统，拆分成小而简单但需要多个系统配合的业务系统。从业务的角度来看，任务分解既不会减少功能，也不会减少代码量（事实上代码量可能还会增加，因为从代码内部调用改为通过服务器之间的接口调用），任务分解能够提升性能的主要原因是：

1. 简单的系统更容易做到高性能：系统的功能越简单，影响性能的点就越少，就更加容易进行有针对性的优化。
2. 可以针对单个任务进行扩展：当各个逻辑任务分解到独立的子系统后，整个系统的性能瓶颈更加容易发现，而且发现后只需要针对有瓶颈的子系统进行性能优化或者提升，不需要改动整个系统，风险会小很多。

**最终决定业务处理性能的还是业务逻辑本身，业务逻辑本身没有发生大的变化下，理论上的性能是有一个上限的，系统拆分能够让性能逼近这个极限，但无法突破这个极限**。因此，任务分解带来的性能收益是有一个度的，并不是任务分解越细越好，而对于架构设计来说，如何把握这个粒度就非常关键了。

## 高可用

> 系统**无中断**地执行其功能的能力，代表系统的可用性程度，是进行系统设计时的准则之一。

本质上都是通过“**冗余**”来实现高可用。高可用的“冗余”解决方案，单纯从形式上来看，和高性能是一样的，都是通过增加更多机器来达到目的，但其实本质上是有根本区别的：**高性能增加机器目的在于“扩展”处理性能；高可用增加机器目的在于“冗余”处理单元**。

通过冗余增强了可用性，但同时也带来了复杂性。

### 计算高可用

计算的特点是**无论从哪台机器上进行计算，同样的算法和输入书记，产出的结果都是一样的**，所以将计算从一台机器迁移到另一台对业务没有影响。

![image](/images/f4c0ae8e1b5dfbc8e58baa8b31dfeab7.png)

- 需要增加一个任务分配器
- 任务分配器和真正的业务服务器之间有连接和交互
- 任务分配器需要增加分配算法（主备【冷备、温备、热备】、主主、多主多倍【2主2备、4主0备】）

### 存储高可用

对于需要存储数据的系统来说，整个系统的高可用设计关键点和难点就在于“**存储高可用**”。存储与计算相比，有一个本质上的区别：**将数据从一台机器搬到到另一台机器，需要经过线路进行传输**。

线路的传输是有延迟的，速度在毫秒级别，距离越长延迟越高，各种异常情况（传输中断、丢包、拥塞）会导致延迟更高，对于高可用系统来说，意味着整个系统在某个时间点撒谎嗯，数据肯定是不一致的。。按照“**数据 + 逻辑 = 业务**”这个公式来套的话，数据不一致，即使逻辑一致，最后的业务表现就不一样了。

如果完全不做冗余，系统的整体高可用又无法保证，所以**存储高可用的难点不在于如何备份数据，而在于如何减少或者规避数据不一致对业务造成的影响**。

> 分布式领域中著名的 CAP 定理，从理论上论证了存储高可用的复杂度。存储高可用不可能同时满足“**一致性、可用性、分区容错性**”，最多满足其中两个，这就要求我们在做架构设计时结合业务进行取舍。

### 高可用状态决策

无论是计算高可用还是存储高可用，其基础都是“**状态决策**”，即系统需要能够判断当前的状态是正常还是异常，如果出现了异常就要采取行动来保证高可用。

如果状态决策本身都有错误或有偏差，那么后续的任何行动和处理都没有意义，但是**通过冗余来实现的高可用系统，状态决策本质上不可能做到完全正确**。

常见的几种决策方式包括：

1. 独裁式
2. 协商式
3. 民主式

#### 独裁式

存在一个独立的决策主体，称为“决策者”，负责收集信息然后进行决策；所有冗余的个体，称为“上报者”，都将状态信息发送给决策者。

独裁式的决策方式不会出现决策混乱的问题，因为只有一个决策者，但是当决策者本身故障时，整个系统就无法实现准确的状态决策。如果决策者本身又做一套状态决策，那就陷入一个递归的死循环了。

#### 协商式

两个独立的个体通过交流信息，然后根据规则进行决策，**最常用的协商式决策就是主备决策**。这个架构的基本协商规则可以设计成：

1. 2 台服务器启动时都是备机。
2. 2 台服务器建立连接。
3. 2 台服务器交换状态信息。
4. 某 1 台服务器做出决策，成为主机；
5. 另一台服务器继续保持备机身份。

协商式决策的架构不复杂，规则也不复杂，其难点在于，如果两者的信息交换出现问题（比如主备连接中断），此时状态决策应该怎么做。

- 如果备机在连接中断的情况下认为主机故障，则备机需要升级为主机，但实际上此时主机并没有故障，那么系统就出现了两个主机
- 如果备机在连接中断的情况下不认为主机故障，则此时如果主机真的发生故障，那么系统就没有主机了
- 如果为了规避连接中断对状态决策带来的影响，可以增加更多的连接（双连接、三连接），这样可以降低连接中断带来的影响，但不能彻底解决，同时会引入多条连接信息（连接之间传递的信息不同）之间的取舍问题，这个问题无解

**协商式状态决策在某些场景总是存在一些问题的**。

#### 民主式

多个独立的个体通过投票的方式来进行状态决策。

民主式决策和协商式决策比较类似，其基础都是独立的个体之间交换信息，每个个体做出自己的决策，然后按照“多数取胜”的规则来确定最终的状态。**不同点在于民主式决策比协商式决策要复杂得多**，`ZooKeeper` 的选举算法 `Paxos`，绝大部分人都看得云里雾里，更不用说用代码来实现这套算法了。除了算法复杂，民主式决策还有一个固有的缺陷：**脑裂**。

> 脑裂的根本原因是，原来统一的集群因为连接中断，造成了两个独立分隔的子集群，每个子集群单独进行选举，于是选出了 2 个主机。

为了解决脑裂问题，民主式决策的系统一般都采用“**投票节点数必须超过系统总节点数一半**”规则来处理。这种方式虽然解决了脑裂问题，但同时降低了系统整体的可用性，系统因为节点故障导致存活节点数少于一半，此时系统不会选出主节点，整个系统就相当于宕机了，尽管此时仍然有正常运行的节点。

## 可扩展性

## 低成本、安全、规模

## 架构设计三原则

## 架构设计流程

### 识别复杂度

### 设计备选方案

### 评估和选择备选方案

### 详细方案设计
