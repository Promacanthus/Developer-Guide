---
title: "05 RPC高级"
date: 2020-05-28T16:37:24+08:00
draft: true
---

## 异步RPC

### 吞吐量

影响RPC吞吐量的根本原因就是由于处理 RPC 请求比较耗时，并且 CPU 大部分的时间都在等待而没有去计算，从而导致 CPU 的利用率不够。

> 除非在网络比较慢或者调用方使用不当的情况下，否则，在大多数情况下，刨除业务逻辑处理的耗时时间，RPC 本身处理请求的效率就算在比较差的情况下也不过是**毫秒级**的。

RPC 请求的耗时大部分都是**业务耗时**，比如业务逻辑中有访问数据库执行慢 SQL 的操作。

在大多数情况下，影响到 RPC 调用的吞吐量的原因也就是**业务逻辑处理慢了**，**CPU大部分时间都在等待资源**。要提升吞吐量，其实关键就两个字：“**异步**”。

### 异步化

#### 调用方

一次 RPC 调用的本质就是：

1. 调用方向提供方发送一条请求消息
2. 提供方收到消息后进行处理
3. 处理之后响应给调用方一条响应消息
4. 调用方收到响应消息之后再进行处理
5. 最后将最终的返回值返回给动态代理

对于调用方来说，向提供方发送请求消息与接收提供方发送过来的响应消息，这两个处理过程是两个完全独立的过程，这两个过程甚至在大多数情况下都不在一个线程中进行。

所以，对于 RPC 框架，无论是同步调用还是异步调用，调用方的内部实现都是异步的。

#### 提供方

RPC提供方接收到请求的二进制消息之后：

1. 根据协议进行拆包解包；
2. 将完整的消息进行解码并反序列化
3. 获得到入参参数之后再通过反射执行业务逻辑

对二进制消息数据包拆解包的处理是在处理网络 IO 的线程中处理，而解码与反序列化的过程也往往在 IO 线程中处理，业务逻辑交给专门的业务线程池处理，以防止由于业务逻辑处理得过慢而影响到网络 IO 的处理。

> 业务线程池的线程数一般只会配置到 200，因为在大多数情况下线程数配置到 200 还不够用就说明业务逻辑该优化了。

提供方支持业务逻辑异步是个比较难处理的问题，因为提供方执行完业务逻辑之后，要对返回值进行序列化并且编码，将消息响应给调用方，如果是异步处理，业务逻辑触发异步之后方法就执行完了，来不及将真正的结果进行序列化并编码之后响应给调用方。

因此，需要 RPC 框架提供一种**回调方式**，让业务逻辑可以异步处理，处理完之后调用 RPC 框架的回调接口，将最终的结果通过回调的方式响应给调用方。
