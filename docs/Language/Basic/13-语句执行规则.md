# Go语句及其执行规则

> Don't communicate by sharing memory; share memory by communicating.
> 不要通过共享数据来通讯，以通讯的方式来共享数据。

channel类型的值，被用来以通讯的方式共享数据。一般被用来在不同的goroutine（代表并发编程模型中的用户级线程）之间传递数据。

## 进程与线程

进程：描述的就是程序的执行过程，是运行着的程序的代表，一个进程其实就是某个程序运行的一个产物。（静静躺在那里的代码是程序、奔跑着、正在发挥功能的代码就是进程）。

线程：总是在进程之内，被视为进程中运行着的控制流（代码执行流程）。

> 一个进程至少包含一个线程，如果只包含一个线程，那么所以代码会被串行执行。**每个进程的第一个线程都会随着该进程的启动而被创建，称它为所属进程的主线程**。如果一个进程包含多个线程，那么代码可以被并发地执行，**除了主线程，其他线程都是进程中已存在的线程创建出来的**。**主线程之外的其他线程，只能由代码显式地创建和销毁**。

### 线程类别

- 系统级线程：在Go语言的运行时中，系统会帮助我们自动地创建和销毁**系统级的线程**（操作系统提供的线程）。
- 用户级线程：架设在系统级线程之上，由用户（我们编写的程序）完全控制的代码执行流程，用户级线程的创建、销毁、调度、状态变更以及其中的代码和数据都完全需要程序自己去实现和处理。

#### 用户级线程

- 优势：用户级线程的创建和销毁不同通过操作系统，速度快，不用等待操作系统去调度它们运行，所以容易控制且灵活。
- 劣势：复杂，如果只是用系统级线程，那么只要指明需要新线程执行的代码片段，并且下达创建或销毁线程的指令就好，其他的具体实现由操作系统代劳。我们必须全权负责与用户级线程相关的所以具体的实现，并且需要和操作系统争取对接，否则可能无法正确运行。

## 调度器

Go语言拥有：

- 独特的并发编程模型
- 用户级线程goroutine
- 强大的用于调度goroutine、对接操作系统的调度器

这个调度器是Go语言运行时系统的重要组成部分，主要负责统筹调配Go并发编程模型中的三个主要元素：

- G（goroutine）:用户级线程
- P（processor）：可以承载若干个goroutine，且能够使这些goroutine适时地与系统级线程对接，并得到真正运行的中介
- M（machine）：系统级线程

> 宏观上讲，由于P的存在，用户级线程和系统级线程可以呈现多对多的关系。

例如：

- 当一个正在与某个系统级线程对接并运行的用户级线程，需要因某个事件（等待IO或锁的解除）而暂停运行的时候，调度器总会及时发现，并把这个用户级线程和系统级线程分离，以释放计算资源供其他等待运行的用户级线程使用。
- 当一个用户级线程需要恢复运行的时候，调度器又会尽快为他寻找空闲的计算资源（包括系统级线程）并安排运行。
- 当系统级线程不够用的时候，调度器会帮我们想操作系统申请新的系统级线程。
- 当某一个系统级线程已经无用时，调度器会负责把它及时销毁掉。

**因为调度器帮我们做了很多事，所以Go程序才能高效地利用操作系统和计算机资源**。程序中所以的用户级线程都会被充分地调度，其中的代码也都会并发地运行，即使用户级线程有数十万计。

![image](/docs/images/GPM.png)https://github.com/Promacanthus/Golang-Guide/raw/master/docs/images/


## goroutine最佳实践

```go
package main

import "fmt"

func main() {
    for i := 0; i < 10; i++ {
        go func() {
            fmt.Println(i)
        }()
    }
}
```

代码执行后，不会有任何内容输出。

与一个进程总会有一个主线程类似，每一个独立的Go程序运行起来总会有一个主用户线程（goroutine）。**这个主goroutine会在Go程序的运行准备工作完成后被自动地启用**，并不需要任何手动操作。

> 每条go语句一般都会携带一个函数调用，这个被调用的函数被称为go函数，主用户线程（goroutine）的go函数，就是那个程序入口的main函数。

### 已经存在的用户级线程会被优先复用：

**go函数被真正执行的时间，总会与其所属的go语句被执行的时间不同**。当程序执行到一条go语句，Go语言运行时系统，会先试图从某个存放空闲的用户级线程的队列中获取某个用户级线程，它只有找不到空闲的用户级线程的情况们才会去创建一个新的用户级线程。

### 用户级线程的创建成本很低：

创建一个新的用户级线程并不会像创建一个进程或者一个系统级线程那样，必须通过操作系统的系统调用来完成，在Go语言的运行时系统内部就可以完成了，一个用户级线程就相当于需要并发执行代码片段的上下文环境。

在拿到空闲的用户级线程之后，Go语言运行时系统会用这个用户级线程去包装那个go函数（函数中的代码），然后再把这个用户级线程追加到某个可运行的用户级线程队列（先进先出）中。虽然在队列中被安排运行的时间很快，上述的准备工作也不可避免，因此存在一定时间消耗。**所以go函数的执行时间，总是会明显滞后（相对于CPU和Go程序）与go语句的执行时间**。

**只要go语句本身执行完毕，Go程序完全不用等待go函数的执行，它会立刻去执行后面的语句，这就是异步并发执行**。

> 注意：一点主用户级线程（main函数中的那些代码）执行完毕，当前的Go程序就会结束运行。如果在Go程序结束的那一刻，还有用户级线程没有运销，那就没有机会运行了。

严格的说，Go语言并不会保证用户级线程会以怎样的顺序运行，因为主用户级线程会与手动启动的其他用户级线程一起接受调度，又因为调度器很可能会在用户级线程中的代码只执行了一部分的时候暂停，以期所有的用户级线程有更公平的运行机会。所以哪个用户级线程先执行完，是不可预知的，除非使用了某种Go语言提供的方式进行人为干预。

## 主用户级线程等待其他用户级线程

1. 让主用户级线程`Sleep()`一会：但是时间难以把握
2. 其他用户级线程运行完毕之后发出通知：创建一个通道，长度与手动启动的用户级线程一致，每个用户级线程运行完毕的时候向通道中发送一个值（在go函数的最后发送），在main函数的最后接收通道中的值，接收次数与手动启动的用户级线程数量一直
3. sync包中的`sync.WaitGroup`类型

```go
sign := make(chan struct{}, num)        // 结构体类型的通道

sign <- struct{}{}

<- sign
```

`struct{}`类似于空接口`interface{}`，代表既不包含任何字段也不拥有任何方法的空结构体类型。

**`struct{}`类型的值表示法只要一个，`struct{}{}`，它占用的内存空间是0字节。这个值在整个Go程序中永远都只会存在一份**。无数次的试用这个值的字面量，但是用到的却是同一个值。

## 用户级线程按顺序执行

```go
package main

import （
            "fmt"
            "sync/atomic"
            "time"
        )

func main() {
    // 用户级线程随机执行
    for i := 0; i < 10; i++ {
        go func() {
            fmt.Println(i)
        }()
    }

    // 用户级线程按顺序执行
    for i := 0; i < 10; i++ {
        go func(i int) {            // 让go函数接收一个int型参数，在调用它的时候，把变量传进去
            fmt.Println(i)      // 这样Go语言包装每个用户级线程都可以拿到一个唯一的整数
        }(i)
    }

    // 在go语句被执行时，传给go函数的参数`i`会被先求值，如此就得到了档次迭代的序号，
    // 之后，无论go函数会在什么时候执行，这个参数值都不会变，
    // 也就是go函数中调用`fmt.Prinrln`函数打印的一定是那个当次迭代的序号。

    var count uint32
    
    for i := uint32(0); i < 10; i++ {
        go func(i uint32) {
            fn := func() {
                fmt.Println(i)
            }
            trigger(i, fn)
        }(i)
    }

    trigger := func(i uint32, fn func()) {
        for {
            if n := atomic.LoadUint32(&count); n == i {     // 原子操作
                fn()
                atomic.AddUint32(&count, 1)                 // 原子操作
                break
            }
            time.Sleep(time.Nanosecond)
        }
    }

    trigger(10, func(){})
}
```
