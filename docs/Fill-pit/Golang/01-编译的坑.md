# 01-编译的坑

## 交叉、动态、静态

### 问题一

默认情况下，golang的编译是动态编译，通过环境变量CGO_ENABLED控制，默认开启cgo，允许在Go代码中调用C代码，如下所示：

```bash
go env

...
GCCGO="gccgo"
CC="gcc"
# 就是这个，默认开启
CGO_ENABLED="1"
CGO_CFLAGS="-g -O2"
CGO_CPPFLAGS=""
CGO_CXXFLAGS="-g -O2"
CGO_FFLAGS="-g -O2"
CGO_LDFLAGS="-g -O2"
GOGCCFLAGS="-fPIC -m64 -pthread -fmessage-length=0 -fdebug-prefix-map=/tmp/go-build071200252=/tmp/go-build -gno-record-gcc-switches"
...

```

动态编译完成后的二进制文件，放在Alpine基础镜像中运行报错如下，但是放在ubuntu基础镜像中可以运行：

```bash
standard_init_linux.go:211: exec user process caused "no such file or directory"
```

因为，在制作Alpine的时候，是基于`musl libc`和busybox构建的，导致动态依赖的二进制文件在运行时找不到依赖的文件。

#### 问题一解决方案

1. 使用动态编译后运行在大基础镜像中，即包含动态调用的C库的基础镜像
2. 使用静态编译后运行在小基础镜像中

> 注意，有的情况下，可能会出现不能静态编译的依赖包，如libpcap这个库。

### 问题二

使用`CGO_ENABLED=1 go build -a -ldflags '-extldflags "-static"' .`编译web应用后，无法在scratch和Alpine基础镜像中运行，但是可以直接在开发环境的服务器上运行。

具体表现为，容器启动后直接退出，`Exited (127) xxx ago`。

#### 问题二解决方案

使用`CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o main .`,编译后的web应用可以正常运行。

## 分析总结

一切要从golang的可移植性（交叉编译）说起。说到一门编程语言可移植性，一般从下面两个方面考量：

- **语言自身**被移植到不同平台的容易程度；
- 通过这种**语言编译出来的应用程序**对平台的适应性。

```bash
# 查看当前版本支持的操作系统
go tool dist list
```

得益于golang独立实现了runtime，移植起来相对容易，如下图所示。

![porting](../../images/go-runtime-vs-c-runtime.png)

runtime是支撑程序运行的基础。如C语言的运行时`libc`是目前主流操作系统上应用最普遍的运行时，通常以动态链接库的形式(比如：`/lib/x86_64-linux-gnu/libc.so.6`)随着系统一并发布，它的功能大致有如下几个：

1. 提供基础库函数调用，比如：`strncpy`（操作字符串）；
2. 封装`syscall`，它是操作系统提供的API口，当用户层进行系统调用时，代码会trap(陷入)到内核层面执行，并提供同语言的库函数调用，比如：`malloc`（动态分配内存）；
3. 提供程序启动入口函数，比如：linux下的`__libc_start_main`。

> libc等c runtime lib是很早以前就已经实现的了，甚至有些老旧的libc还是单线程的。一些从事`c/c++`开发多年的程序员早年估计都有过这样的经历：那就是链接runtime库时甚至需要选择链接支持多线程的库还是只支持单线程的库。除此之外，c runtime的版本也参差不齐。这样的c runtime状况完全不能满足golang自身的需求；另外Go的目标之一是原生支持并发，并使用goroutine模型，c runtime对此是无能为力的，因为c runtime本身是基于线程模型的。综合以上因素，golang自己实现了runtime，并封装了syscall，为不同平台上的go user level代码提供封装完成的、统一的go标准库；同时Go runtime实现了对goroutine模型的支持。

独立实现的go runtime层将Go user-level code与OS syscall解耦，把Go porting到一个新平台时，将runtime与新平台的syscall对接即可(当然porting工作不仅仅只有这些)；同时，runtime层的实现基本摆脱了Go程序对libc的依赖，这样静态编译的Go程序具有很好的平台适应性。比如：一个compiled for linux amd64的Go程序可以很好的运行于不同linux发行版（centos、ubuntu）下。

### 编译参数说明

参数`-a`，强制重新编译，不利用缓存或已编译好的部分文件，所有包都是最新的代码重新编译和关联

参数`-installsuffix`，在软件包安装的目录中增加后缀标识，以保持输出与默认版本分开（如果使用 `-race` 标识，则后缀就会默认设置为 `-race` 标识，用于区别 race 和普通的版本）

参数`-o`,指定编译后的可执行文件名称

参数`GOOS`，用于标识（声明）程序构建环境的目标操作系统。

参数`GOARCH`，用于标识（声明）程序构建环境的目标计算机架构。

参数`GOHOSTOS`，用于标识（声明）程序运行环境的目标操作系统。

参数`GOHOSTARCH`，用于标识（声明）程序运行环境的目标计算机架构。

参数`CGO_ENABLED`，用于标识（声明）cgo工具是否可用。

> 存在交叉编译的情况时，cgo 工具是不可用的。在标准go命令的上下文环境中，交叉编译意味着程序构建环境的目标计算架构的标识与程序运行环境的目标计算架构的标识不同，或者程序构建环境的目标操作系统的标识与程序运行环境的目标操作系统的标识不同。

在制作容器的时候，特别是最求镜像足够小的时候，比如下面的使用`scratch`来构建，这样必然编译环境和运行环境两者之间的计算机架构和运行环境标识不一致。

那么就要进行交叉编译，而交叉编译不支持 cgo，因此这里要禁用掉它，即必须进行静态编译，关闭 cgo 后，在构建过程中会忽略 cgo 并静态链接所有内置依赖库，而开启 cgo 后，方式将转为动态链接，即动态编译。

常见列表：

|操作系统|GOOS|GOARCH|
---|---|---
Windows32|windows|386
Windows64|windows|amd64
OSX32|darwin|386
OSX64|darwin|amd64
Linux32|linux|386
Linux64|linux|amd64

#### scratch

明确为空的镜像，尤其适合构建“从零开始”的镜像。

```dockerfile
FROM scratch
```

在构建基础镜像（例如[debian](https://registry.hub.docker.com/_/debian/)和[busybox](https://registry.hub.docker.com/_/busybox/)）或超小型镜像（仅包含一个二进制文件以及它所需要的任何内容（例如[hello-world](https://registry.hub.docker.com/_/hello-world/)））的上下文中，此镜像最有用。

从Docker1.5.0开始，DOckerfile中的`FROM scratch`将不进行任何操作，不会在生成的镜像中创建一个额外的层。

[创建一个基础镜像](https://docs.docker.com/develop/develop-images/baseimages/)：从文看出：

1. 使用Docker保留的最小镜像`scratch`作为构建容器的启动，使用`scratch`表示在Dockerfile文件中的下一条指令将会作为生成镜像中的第一个文件系统层。
2. 虽然在DockerHub中有`scratch`，但是不能拉取、运行或者将任何其他镜像贴标签为`scratch`。相反可以在Dockerfile中引用它，如下例子。

```dockerfile
FROM scratch
COPY hello /
CMD ["/hello"]
```

注意 scratch 镜像几乎不包含任何东西，**不支持环境变量**，**也没有shell命令**。 因此，基于 scratch 的镜像通过 ADD 指令进行添加，以此绕过目录创建。

### 静态编译

go程序在编译时会将go runtime一起编译为二进制文件，因此编译完成后的二进制文件比较大。可以使用`ldd (print shared object dependencies)`或`nm (list symbols from object files)`工具查看文件的外部动态库依赖。

```bash
# 编译指令，关键是CGO_ENABLED=0表示关闭
CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o main .

ldd main
    不是动态可执行文件
```

Go将所有运行需要的函数代码都放到了hellogo中，这就是所谓的“静态链接”。但是，并不是所有情况下，Go都能够不依赖外部动态库。

因为有一些库在编写的时候就依赖的外部动态库，使用cgo调用C语言实现的代码，因此在代码中import这些库，最终编译的二进制文件也必要有外部动态依赖，即设置`CGO_ENABLE=0`将会导致编译报错，报错如下所示。

```bash
CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o main .
github.com/google/gopacket/pcap
../../../go/pkg/mod/github.com/google/gopacket@v1.1.17/pcap/pcap.go:30:22: undefined: pcapErrorNotActivated
../../../go/pkg/mod/github.com/google/gopacket@v1.1.17/pcap/pcap.go:52:17: undefined: pcapTPtr
../../../go/pkg/mod/github.com/google/gopacket@v1.1.17/pcap/pcap.go:64:10: undefined: pcapPkthdr
../../../go/pkg/mod/github.com/google/gopacket@v1.1.17/pcap/pcap.go:102:7: undefined: pcapBpfProgram
../../../go/pkg/mod/github.com/google/gopacket@v1.1.17/pcap/pcap.go:103:7: undefined: pcapPkthdr
../../../go/pkg/mod/github.com/google/gopacket@v1.1.17/pcap/pcap.go:261:33: undefined: pcapErrorActivated
../../../go/pkg/mod/github.com/google/gopacket@v1.1.17/pcap/pcap.go:262:33: undefined: pcapWarningPromisc
../../../go/pkg/mod/github.com/google/gopacket@v1.1.17/pcap/pcap.go:263:33: undefined: pcapErrorNoSuchDevice
../../../go/pkg/mod/github.com/google/gopacket@v1.1.17/pcap/pcap.go:264:33: undefined: pcapErrorDenied
../../../go/pkg/mod/github.com/google/gopacket@v1.1.17/pcap/pcap.go:265:33: undefined: pcapErrorNotUp
../../../go/pkg/mod/github.com/google/gopacket@v1.1.17/pcap/pcap.go:265:33: too many errors
```

#### 动态编译静态链接

在Docker化的今天，经常需要静态编译一个Go程序，以便方便放在Docker容器中。即使没有引用其它的第三方包，只是在程序中使用了标准库net,也会发现编译后的程序依赖glibc,这时候需要glibc-static库并且静态链接。编译命令如下。

```bash
CGO_ENABLED=1 go build -a -ldflags '-extldflags "-static"' .
```

实现原理：

1. 将所有生成的`.o`文件都打到一个`.o`文件中
2. 将其交给外部的链接器，比如`gcc/clang`去做最终链接处理
3. 参数中传入`-ldflags 'extldflags "-static"'`，那么`gcc/clang`将会去做静态链接，将`.o`中undefined的符号都替换为真正的代码

通过`-linkmode=external`来强制`cmd/link`采用external linker。

下面的例子将会强制编译为静态链接的二进制文件。

```bash
go build -a -ldflags '-extldflags "-static"' .
# sidecar
/tmp/go-link-136417324/000021.o：在函数‘mygetgrouplist’中：
/opt/go/src/os/user/getgrouplist_unix.go:16: 警告： Using 'getgrouplist' in statically linked applications requires at runtime the shared libraries from the glibc version used for linking
/tmp/go-link-136417324/000020.o：在函数‘mygetgrgid_r’中：
/opt/go/src/os/user/cgo_lookup_unix.go:38: 警告： Using 'getgrgid_r' in statically linked applications requires at runtime the shared libraries from the glibc version used for linking
/tmp/go-link-136417324/000020.o：在函数‘mygetgrnam_r’中：
/opt/go/src/os/user/cgo_lookup_unix.go:43: 警告： Using 'getgrnam_r' in statically linked applications requires at runtime the shared libraries from the glibc version used for linking
/tmp/go-link-136417324/000020.o：在函数‘mygetpwnam_r’中：
/opt/go/src/os/user/cgo_lookup_unix.go:33: 警告： Using 'getpwnam_r' in statically linked applications requires at runtime the shared libraries from the glibc version used for linking
/tmp/go-link-136417324/000020.o：在函数‘mygetpwuid_r’中：
/opt/go/src/os/user/cgo_lookup_unix.go:28: 警告： Using 'getpwuid_r' in statically linked applications requires at runtime the shared libraries from the glibc version used for linking
/tmp/go-link-136417324/000006.o：在函数‘_cgo_26061493d47f_C2func_getaddrinfo’中：
/tmp/go-build/cgo-gcc-prolog:58: 警告： Using 'getaddrinfo' in statically linked applications requires at runtime the shared libraries from the glibc version used for linking
/usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/libpcap.a(nametoaddr.o)：在函数‘pcap_nametoaddr’中：
(.text+0x5): 警告： Using 'gethostbyname' in statically linked applications requires at runtime the shared libraries from the glibc version used for linking
/usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/libpcap.a(nametoaddr.o)：在函数‘pcap_nametonetaddr’中：
(.text+0xc5): 警告： Using 'getnetbyname' in statically linked applications requires at runtime the shared libraries from the glibc version used for linking
/usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/libpcap.a(nametoaddr.o)：在函数‘pcap_nametoproto’中：
(.text+0x305): 警告： Using 'getprotobyname' in statically linked applications requires at runtime the shared libraries from the glibc version used for linking
/usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/libpcap.a(nametoaddr.o)：在函数‘pcap_nametoport’中：
(.text+0xfb): 警告： Using 'getservbyname' in statically linked applications requires at runtime the shared libraries from the glibc version used for linking


ldd sidecar
    不是动态可执行文件

```

### 动态编译

默认golang设置`CGO_ENABLED=1`。

```bash
go build .

ldd sidecar
    linux-vdso.so.1 (0x00007ffda0bb6000)
    libpcap.so.0.8 => /usr/lib/x86_64-linux-gnu/libpcap.so.0.8 (0x00007fcba7fb5000)
    libpthread.so.0 => /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007fcba7d96000)
    libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fcba79a5000)
    /lib64/ld-linux-x86-64.so.2 (0x00007fcba81f6000)
```
